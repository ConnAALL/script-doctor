import bdb
import glob
import json
import os
import pickle
import random
import shutil
import traceback

import hydra
import imageio
import jax
import jax.numpy as jnp
from lark import Lark
import numpy as np
from skimage.transform import resize

from conf.config import Config
from env import PSEnv
from gen_tree import GenPSTree
from parse_lark import TREES_DIR, DATA_DIR, TEST_GAMES, get_tree_from_txt
from ps_game import PSGameTree
from utils_rl import get_env_params_from_config


scratch_dir = 'scratch'
os.makedirs(scratch_dir, exist_ok = True)


@hydra.main(version_base="1.3", config_path='./conf', config_name='config')
def main(config: Config):
    sol_paths = glob.glob(os.path.join('sols', '*'))
    random.shuffle(sol_paths)
    games = [os.path.basename(path) for path in sol_paths]

    with open('games_n_rules.json', 'r') as f:
        games_n_rules = json.load(f)
    games_n_rules = sorted(games_n_rules, key=lambda x: x[1])
    games = [game for game, n_rules in games_n_rules]
    sol_paths = [os.path.join('sols', game) for game in games]

    # tree_paths = [os.path.join(TREES_DIR, os.path.basename(path) + '.pkl') for path in sol_paths]
    # games = [os.path.basename(path)[:-4] for path in sol_paths]
    sols_dir = os.path.join('vids', 'jax_sols')

    for sol_dir, game in zip(sol_paths, games):
        traj_dir = os.path.join(sols_dir, game)
        compile_log_path = os.path.join(traj_dir, 'compile_err.txt')
        if os.path.exists(compile_log_path) and not config.overwrite:
            print(f"Skipping {game} because compile error log already exists")
            continue

        os.makedirs(traj_dir, exist_ok=True)

        with open("syntax.lark", "r", encoding='utf-8') as file:
            puzzlescript_grammar = file.read()
        # Initialize the Lark parser with the PuzzleScript grammar
        parser = Lark(puzzlescript_grammar, start="ps_game", maybe_placeholders=False)
        # min_parser = Lark(min_puzzlescript_grammar, start="ps_game")
        tree = get_tree_from_txt(parser, game)
        og_path = os.path.join(DATA_DIR, 'scraped_games', os.path.basename(game) + '.txt')

        print(f"Processing solution for game: {og_path}")

        try:
            env = PSEnv(tree)
        except KeyboardInterrupt as e:
            raise e
        except bdb.BdbQuit as e:
            raise e
        except Exception as e:
            err_log = traceback.format_exc()
            with open(os.path.join(traj_dir, 'error.txt'), 'w') as f:
                f.write(err_log)
            traceback.print_exc()
            print(f"Error creating env: {og_path}")
            continue

        key = jax.random.PRNGKey(0)
        params = get_env_params_from_config(env, config)

        # 0 - left
        # 1 - down
        # 2 - right
        # 3 - up
        # 4 - action
        action_remap = [3, 0, 1, 2, 4]

        key = jax.random.PRNGKey(0)

        # Get all level solutions previously generated by tree search in javascript.
        level_sols = glob.glob(os.path.join(sol_dir, 'level-*.json'))

        for level_sol_path in level_sols:
            level_i = int(os.path.basename(level_sol_path).split('-')[1].split('.')[0])
            sol_log_path = os.path.join(traj_dir, f'level-{level_i}_solution_err.txt')
            score_log_path = os.path.join(traj_dir, f'level-{level_i}_score_err.txt')
            run_log_path = os.path.join(traj_dir, f'level-{level_i}_runtime_err.txt')
            gif_path = os.path.join(traj_dir, f'level-{level_i}.gif')
            if (os.path.exists(gif_path) or os.path.exists(sol_log_path) or os.path.exists(score_log_path) \
                    or os.path.exists(run_log_path)) and not config.overwrite:
                print(f"Skipping level {level_i} because gif or error log already exists")
                continue

            with open(level_sol_path, 'r') as f:
                sol_dict = json.load(f)
            level_sol = sol_dict['sol']
            level_win = sol_dict['won']
            level_score = sol_dict['score']
            actions = level_sol
            actions = [action_remap[a] for a in actions]
            actions = jnp.array([int(a) for a in actions])


            js_gif_path = os.path.join(sol_dir, f'level-{level_i}_sol.gif')
            level = env.get_level(level_i)
            params = params.replace(level=level)
            print(f"Level {level_i} solution: {actions}")

            def step_env(state, action):
                obs, state, reward, done, info = env.step_env(key, state, action, params)
                return state, state

            try:
                obs, state = env.reset(key, params)
                state, state_v = jax.lax.scan(step_env, state, actions)
                if level_win and not state.win:
                # if not done:
                    with open(sol_log_path, 'w') as f:
                        f.write(f"Level {level_i} solution failed\n")
                        f.write(f"Actions: {actions}\n")
                        # f.write(f"State: {state}\n")
                    print(f"Level {level_i} solution failed")
                elif not level_win and (state.heuristic != level_score):
                    # FIXME: There is a discrepancy between the way we compute scores in js (I actually don't understand
                    # how we're getting that number) and the way we compute scores in jax, so this will always fail.
                    with open(score_log_path, 'w') as f:
                        f.write(f"Level {level_i} solution score mismatch\n")
                        f.write(f"Actions: {actions}\n")
                        f.write(f"Jax score: {state.score}\n")
                        f.write(f"JS score: {level_score}\n")
            except Exception as e:
                traceback.print_exc()
                print(f"Error running solution: {og_path}")
                err_log = traceback.format_exc()
                with open(run_log_path, 'w') as f:
                    f.write(err_log)
                continue

            # Use jax tree map to add the initial state
            state_v = jax.tree.map(lambda x, y: jnp.concatenate([x[None], y]), state, state_v)

            frames = jax.vmap(env.render, in_axes=(0, None))(state_v, None)
            frames = frames.astype(np.uint8)

            # Scale up the frames
            print(f"Scaling up frames for level {level_i}")
            scale = 10
            frames = jnp.repeat(frames, scale, axis=1)
            frames = jnp.repeat(frames, scale, axis=2)

            # Save the frames
            print(f"Saving frames for level {level_i}")
            frames_dir = os.path.join(traj_dir, 'frames')
            os.makedirs(frames_dir, exist_ok=True)
            for i, frame in enumerate(frames):
                imageio.imsave(os.path.join(frames_dir, f'level-{level_i}_sol_{i:03d}.png'), frame)

            # Make a gif out of the frames
            imageio.mimsave(gif_path, frames, duration=0.1, loop=0)

            # Copy over the js gif
            shutil.copy(js_gif_path, os.path.join(traj_dir, f'level-{level_i}_js.gif'))

    print(f"Finished validating solutions in jax.")


if __name__ == '__main__':
    main()